# 函数

## 命名
函数越短小越好起名字  
长而具有描述性的名称比短而费解的名称要好  
当你觉得一个命名更好的时候，就要果决的换掉它
包含动词，表示事情发生    
见名知意  

## 参数
最好的参数是0，大于两个的参数建议改成options  
- 标识参数
  向函数传入boolean是骇人听闻的做法，本质就是大声宣布这个函数做的不止一件事情
  ```ts
  function xxx(noNeedJump: boolean) {
    // xxx
    if (noNeedJump) return;
    // xxx
  }
  ```
- 二三元函数
  除了要知道参数的意思还需知道参数所在的顺序，加大了正确使用的难度
  ```ts
  function getPoint(x: number, y: number) {}
  ```
  ```ts
  function isInteger(max?: number, min?: number, digits?: number) {
    const value = control.value;
    // 校验传入的数据 是否满足最大、小值，小数位的个数
  }
  ```

## 作用
- 用于转换
  接收参数，输出
- 改变系统状态
  系统：泛指上下文

## 内容
- 短小
  函数的第一规则是短小，第二规则是还要更短小  
  建议函数体不大于20行
  什么是短小，是代码行数？发散的来看无重复性的代码行数(有重复就要想办法去做一个复用)
- 单一职责  
  一个函数只做一件事，做好这件事情  
  结合短小，每个函数依序把你带到下一个函数  
  内部的缩进不应该大于一层或两层，如果出现了多层，那函数想表达的意思就存在多种，这时候就需要拆分成更小的函数，利用return来降低层级，异常或简单逻辑优先原则
  ```ts
  (value: string) => {
    if (value.length < 5) {
      // xxxxx
    } else {
      // xxxxx
      // xxxxx
      // xxxxx
      // xxxxx
    }
  }
  ```
  区段：同一代码体的不同代码块，每一块表达一段逻辑  
  ```ts
  (value: string) => {
    if (value.length < 5) {
      // xxxxx
      return;
    }

    // xxxxx
    // xxxxx
    // xxxxx
    // xxxxx
  }
  ```
  > 结构化编程
  函数只应该有一个入口一个出口，循环中不能有 break 和 continue  
  我的理解是极致的单一职责  
  但是在写代码的时候是不太可能做到这种，只要你的函数保持短小，偶尔出现 return 也没关系  
- 无副作用
  写类方法和业务函数，大部分无法做到这个程度  
  以后详解函数式编程  
- 不要在操作类的函数中返回操作的结果
  ```ts
  function deleteXxx(): 'ERROR' | 'SUCCESS' {
    // xxxxx
    return false;
  }

  if (deleteXxx() === 'ERROR') {
    // 如果操作未成功如何
  }
  ```
- 错误处理就是一件单独的事  
- 如果存在大段相同的代码就应该抽出来  
  修改的时候，需要改动每个重复的地方，加大了出错的风险  
  并且，代码的可读性也因为重复的抽离而得到了提升  
- 每一个函数都要有自己的一个抽象层级  
  这是保证函数短小和只做一件事情的要诀
  读代码是自顶向下的，每一层级的函数代码只做自己层级抽象的事情，不要跨级
- switch
  对于类，利用多态将switch埋藏在底层，上层的抽象都是相同的调用  
  写成配置型的，每次有新的状态只需要增加配置，配置中提供相同的接口，上层的配置调用的代码还是相同的  

## 重复
许多原则和实践规则都是为了控制与消除重复而创建的
- 面向对象
  将代码集中到基类，避免冗余  
- 组件化  
以上也是双刃剑，因为集中和复用  
所以某个地方想要特殊的处理是改动基类还是继续扩展，考验的是代码设计人员的能力  

## 如何写出这样的函数
先实现后优化，不要一开始就秉持上面的所有规则去写代码，那样是写不好的  
只有先写出长函数，才知道怎么去划分层级，拆解小的函数  
不断按照以上的规则去审视自己的代码，优化，得到的就是好的代码  